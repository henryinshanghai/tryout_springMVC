服务端推送技术

CS结构的通信方式；
特征：客户端主动发起请求，服务端被动响应；
    问题：但是如果服务端的信息被更新了，客户端并不能及时地得到这些响应；

目标：让客户端能够及时地获取到服务端信息的改动；
手段1：在客户端使用AJAX请求 来 不断轮询服务器。从而能够尽量在第一时间获取到服务端信息的变化
特征：由于服务端需要一直维持着连接，所以服务器表示压力很大

手段2：使用服务器的推送技术，由服务器把更新后的信息 发送给 客户端；
流程：
    1 当客户端向 服务端发送请求，服务端会先抓住这个请求不放；
    2 等 有数据更新的时候，再 返回给客户端；
    3 在客户端接受到消息后，再向服务端发送请求；
    4 重复以上过程
特征：
    由于 服务器在有数据更新时才会返回给客户端，因此 客户端请求的频率得到了很好的控制。
    服务器表示没什么压力了
具体实现：
    1 基于SSE（Server Send Event）的服务器端推送技术；
        特征：需要新式浏览器的支持；

        演示流程：
            1 http://localhost:8080/springmvcDemo/sse 访问到 指定的接口，跳转到指定的页面sse.jsp;
            2 在 sse.jsp 页面中，在SSE的客户端对象（EventSource）上 定义对服务器端指定接口的 监听事件；
            3 在服务端，睡一会，返回一个字符串给客户端；
        特征：服务端控制了客户端访问的频率，而不是客户端无脑地进行轮询；

------
    2 基于Servlet3.0+的 异步方法特性；
        特征：跨浏览器；

    演示流程：
        1 http://localhost:8080/springmvcDemo/async 访问到指定的接口， 跳转到指定的页面async.jsp;
        2 在 async.jsp页面中，向服务端的接口发送AJAX请求 - 请求返回后，调用自身（继续向服务端发送相同的请求）
        3 在Controller类型中，定义 /defer接口；
        4 在Service类型中， 定义 getAsyncUpdate()方法；
            4-1 方法返回 deferredResult;
            4-2 定义refresh()方法， 并且定时执行它 ———— 这是服务端的刷新，通过这种方式设置了客户端的调用频率
            note : this is actually a bit blurry.


手段3：双向通信技术 —— WebSocket。 TBD

